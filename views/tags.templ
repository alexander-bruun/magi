package views

import (
    "fmt"
    "strings"
)

// TagsDropdown renders the Tags filter button and dropdown form
templ TagsDropdown(path string, targetID string, currentSort string, currentOrder string, selectedTags []string, tagMode string, allTags []string) {
    <div class="uk-inline tags-inline-block">
        <button id="tag-filter-btn" class="uk-btn uk-btn-default uk-btn-icon" type="button" aria-label="Filter by tags">
            <uk-icon icon="Tag"></uk-icon>
        </button>
        <div id="tag-filter-drop" data-trigger-id="tag-filter-btn" class="uk-drop uk-dropdown min-w-64 p-3" data-uk-dropdown="mode: click; pos: bottom-center; offset: 6; flip: false; animation: uk-anmt-slide-top-sm; duration: 100">
            <form id="tag-filter-form" class="uk-form">
                <input type="hidden" name="sort" value={ currentSort }>
                <input type="hidden" name="order" value={ currentOrder }>
                <input type="hidden" name="tag_mode" value={ strings.ToLower(tagMode) }>
                <div class="uk-margin-small">
                    <div class="uk-text-center tags-controls-center">
                        <div class="uk-inline">
                            <div class="uk-btn-group">
                                @TagModeToggleButton(path, targetID, tagMode)
                                @TagActionButton(path, targetID, "Apply filters", "Check", "uk-btn-primary", true)
                                @TagActionButton(path, targetID, "Clear filters", "x", "uk-btn-destructive", false)
                            </div>
                        </div>
                    </div>
                </div>
                <div id="tag-list" class="uk-margin-small-top tags-list-scroll">
                    @TagsFragment(allTags, selectedTags)
                </div>
            </form>
        </div>
    </div>
}

// Button-only to allow grouping with other controls
templ TagsFilterButton(path string, targetID string) {
    <button id="tag-filter-btn" class="uk-btn uk-btn-default uk-btn-icon" type="button" aria-label="Filter by tags">
        <uk-icon icon="Tag"></uk-icon>
    </button>
}

// Drop-only to be placed outside button group
templ TagsFilterDrop(path string, targetID string, currentSort string, currentOrder string, selectedTags []string, tagMode string) {
    <div id="tag-filter-drop" data-trigger-id="tag-filter-btn" class="uk-drop uk-dropdown min-w-64 p-3" data-uk-dropdown="mode: click; pos: bottom-center; offset: 6; flip: false; animation: uk-anmt-slide-top-sm; duration: 100">
        <form id="tag-filter-form" class="uk-form">
            <input type="hidden" name="sort" value={ currentSort }>
            <input type="hidden" name="order" value={ currentOrder }>
            <input type="hidden" name="tag_mode" value={ strings.ToLower(tagMode) }>
            <div class="uk-margin-small">
                <div class="uk-text-center tags-controls-center">
                    <div class="uk-inline">
                        <div class="uk-btn-group">
                            @TagModeToggleButton(path, targetID, tagMode)
                            @TagActionButton(path, targetID, "Apply filters", "Check", "uk-btn-primary", true)
                            @TagActionButton(path, targetID, "Clear filters", "x", "uk-btn-destructive", false)
                        </div>
                    </div>
                </div>
            </div>
            <div id="tag-list" class="uk-margin-small-top tags-list-scroll" hx-get="/series/tags/fragment" hx-trigger="revealed" hx-target="this" hx-swap="innerHTML">
            </div>
        </form>
    </div>
}

// TagModeToggleButton renders the toggle button for "Match all/any" tags
templ TagModeToggleButton(path string, targetID string, tagMode string) {
    {{ isAny := strings.ToLower(tagMode) == "any" }}
    {{ nextMode := "all" }}
    if isAny {
        {{ nextMode = "all" }}
    } else {
        {{ nextMode = "any" }}
    }
    <button type="button" class="uk-btn uk-btn-default uk-btn-icon"
        hx-get={ path }
        hx-target={ "#" + targetID }
        hx-push-url="true"
        hx-replace-url="true"
        hx-include="#tag-filter-form, #search-filter-input, #account-media-list-search-input"
        hx-vals={ fmt.Sprintf("{\"tag_mode\":\"%s\"}", nextMode) }
        title={ func() string { if isAny { return "Switch to match all tags" } else { return "Switch to match any tags" } }() }
        aria-label={ func() string { if isAny { return "Match all tags" } else { return "Match any tags" } }() }
        onclick="document.getElementById('tag-filter-drop')?.classList.remove('uk-open');">
        if isAny {
            // Current: any. Show icon for switching to ALL
            <uk-icon icon="Equal"></uk-icon>
        } else {
            // Current: all. Show icon for switching to ANY
            <uk-icon icon="Asterisk"></uk-icon>
        }
    </button>
}

// TagActionButton renders apply/clear buttons for the tag filter
templ TagActionButton(path string, targetID string, label string, icon string, btnClass string, includeAllInputs bool) {
    {{ includeSelector := "#tag-filter-form" }}
    if !includeAllInputs {
        {{ includeSelector = "#tag-filter-form input[name=sort], #tag-filter-form input[name=order], #tag-filter-form input[name=tag_mode], #type-filter-form input[name=types], #search-filter-input, #account-media-list-search-input" }}
    } else {
        {{ includeSelector = "#tag-filter-form, #type-filter-form input[name=types], #search-filter-input, #account-media-list-search-input" }}
    }
    {{ buttonType := "submit" }}
    if !includeAllInputs {
        {{ buttonType = "button" }}
    }
    <button type={ buttonType } 
        class={ "uk-btn uk-btn-icon " + btnClass }
        aria-label={ label }
        title={ label }
        hx-get={ path }
        hx-target={ "#" + targetID }
        hx-push-url="true"
        hx-replace-url="true"
        hx-include={ includeSelector }
        onclick="document.getElementById('tag-filter-drop')?.classList.remove('uk-open');">
        <uk-icon icon={ icon }></uk-icon>
    </button>
}

// TagsFragment renders the grid of tag checkboxes
templ TagsFragment(allTags []string, selected []string) {
    {{ selectedMap := make(map[string]bool) }}
    for _, v := range selected {
        {{ selectedMap[strings.ToLower(strings.TrimSpace(v))] = true }}
    }
    <div class="grid grid-cols-1 gap-y-3 tags-grid-padding">
        for _, tag := range allTags {
            {{ isChecked := selectedMap[strings.ToLower(tag)] }}
            <div class="uk-margin-small flex items-center">
                <label class="inline-flex items-center gap-3 min-w-0 w-full">
                    <input class="uk-checkbox shrink-0" type="checkbox" name="tags" value={ tag } checked?={ isChecked }>
                    <span class="leading-none flex-1 min-w-0 tags-text-truncate">{ tag }</span>
                </label>
            </div>
        }
    </div>
}
