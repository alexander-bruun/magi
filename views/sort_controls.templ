package views

import (
    "fmt"
    "github.com/alexander-bruun/magi/models"
)

// Usage examples:
//  Global mangas page:
//    @GenericMangaListing("/mangas", "manga-listing", true, mangas, currentPage, totalPages, sort, order, "No mangas...", selectedTags, tagMode, allTags)
//  Account favorites page:
//    @GenericMangaListing("/account/favorites", "account-manga-list", false, mangas, currentPage, totalPages, sort, order, "You have no favorites yet.", nil, "", nil)
// The targetID must match the container div id so HTMX swaps update the correct region.

// GenericMangaListing consolidates sort controls + optional tag filters + results grid + pagination.
// Parameters:
//  - path: base path for the listing (e.g. /mangas or /account/favorites)
//  - targetID: DOM id that HTMX swaps (e.g. "manga-listing" or "account-manga-list")
//  - includeTags: when true, render tag dropdown & include tag filter htmx includes
//  - mangas: slice of mangas to render
//  - currentPage / totalPages / sort / order: listing state
//  - emptyMessage: message when no results
//  - selectedTags/tagMode/allTags: only used when includeTags is true
// For account pages, pass includeTags=false. For the global mangas page, pass includeTags=true.
templ GenericMangaListingWithTypes(path string, targetID string, includeTags bool, mangas []models.Manga, currentPage int, totalPages int, sort string, order string, emptyMessage string, selectedTags []string, tagMode string, allTags []string, selectedTypes []string, allTypes []string, searchFilter string) {
    @UnifiedSortControlsWithTypes(path, targetID, includeTags, sort, order, selectedTags, tagMode, allTags, selectedTypes, allTypes, searchFilter)
    if len(mangas) > 0 {
        @MangaGrid(mangas, 300, 450, false, false)
        <div class="flex justify-center items-center py-8">
            @UnifiedPagination(path, targetID, includeTags, totalPages, currentPage, sort, order)
        </div>
    } else {
        @EmptyState(emptyMessage)
    }
}

// Backward-compatible wrapper without types (used by account pages initially)
templ GenericMangaListing(path string, targetID string, includeTags bool, mangas []models.Manga, currentPage int, totalPages int, sort string, order string, emptyMessage string, selectedTags []string, tagMode string, allTags []string) {
    @GenericMangaListingWithTypes(path, targetID, includeTags, mangas, currentPage, totalPages, sort, order, emptyMessage, selectedTags, tagMode, allTags, nil, nil, "")
}

// UnifiedSortControls merges previous SortControls + SharedSortControls logic. Now supports optional Types filter.
// When includeTags=true it renders tag dropdown and mimics original mangas page behaviour.
templ UnifiedSortControlsWithTypes(path string, targetID string, includeTags bool, currentSort string, currentOrder string, selectedTags []string, tagMode string, allTags []string, selectedTypes []string, allTypes []string, searchFilter string) {
    <div class="flex justify-between items-center gap-2 my-4">
        {{ allowedSorts := models.GetAllowedMangaSortOptions() }}
        {{ sorts := []struct{ Key, Label string }{} }}
        for _, opt := range allowedSorts {
            switch opt.Key {
                case "name":
                    {{ sorts = append(sorts, struct{ Key, Label string }{"name", "Title"}) }}
                case "type":
                    {{ sorts = append(sorts, struct{ Key, Label string }{"type", "Type"}) }}
                case "year":
                    {{ sorts = append(sorts, struct{ Key, Label string }{"year", "Year"}) }}
                case "status":
                    {{ sorts = append(sorts, struct{ Key, Label string }{"status", "Status"}) }}
                case "content_rating":
                    {{ sorts = append(sorts, struct{ Key, Label string }{"content_rating", "Content rating"}) }}
                case "created_at":
                    {{ sorts = append(sorts, struct{ Key, Label string }{"created_at", "Created"}) }}
                case "updated_at":
                    {{ sorts = append(sorts, struct{ Key, Label string }{"updated_at", "Updated"}) }}
            }
        }
        if includeTags {
            // Original mangas page behavior (depends on #tag-filter-form produced by TagsDropdown)
            <div class="flex items-center gap-2">
                <div class="uk-inline">
                    <uk-select placeholder="Sort by" cls-custom="button: uk-btn uk-btn-default uk-btn-small" hx-get={ path } hx-target={ "#" + targetID } hx-include="#manga-sort-select, #tag-filter-form input[name=order], #tag-filter-form input[name=tag_mode], #tag-filter-form input[name=tags], #type-filter-form input[name=types], #search-filter-input" hx-push-url="true" hx-replace-url="true" hx-trigger="uk-select:input, change">
                        <select id="manga-sort-select" hidden name="sort">
                            for _, s := range sorts {
                                if s.Key == currentSort || (currentSort == "title" && s.Key == "name") {
                                    <option value={ s.Key } selected>{ s.Label }</option>
                                } else {
                                    <option value={ s.Key }>{ s.Label }</option>
                                }
                            }
                        </select>
                    </uk-select>
                </div>
                <div class="uk-inline" style="position: relative;">
                    <input
                        id="search-filter-input"
                        class="uk-input uk-form-small"
                        type="text"
                        name="search"
                        placeholder="Search by title..."
                        value={ searchFilter }
                        style="padding-right: 32px;"
                        hx-get={ path }
                        hx-target={ "#" + targetID }
                        hx-include="#manga-sort-select, #tag-filter-form input[name=order], #tag-filter-form input[name=tag_mode], #tag-filter-form input[name=tags], #type-filter-form input[name=types]"
                        hx-push-url="true"
                        hx-replace-url="true"
                        hx-trigger="input changed delay:300ms, search"
                    />
                    if searchFilter != "" {
                        <button
                            type="button"
                            class="uk-btn uk-btn-icon uk-btn-small"
                            style="position: absolute; right: 2px; top: 50%; transform: translateY(-50%); padding: 0; width: 24px; height: 24px; min-height: 24px; background: transparent; border: none;"
                            hx-get={ path }
                            hx-target={ "#" + targetID }
                            hx-include="#manga-sort-select, #tag-filter-form input[name=order], #tag-filter-form input[name=tag_mode], #tag-filter-form input[name=tags], #type-filter-form input[name=types]"
                            hx-vals='{"search":""}'
                            hx-push-url="true"
                            hx-replace-url="true"
                            aria-label="Clear search"
                            onclick="document.getElementById('search-filter-input').value = '';"
                        >
                            <uk-icon icon="X" ratio="0.8"></uk-icon>
                        </button>
                    }
                </div>
            </div>
            <div class="flex items-center gap-2">
                @TagsDropdown(path, targetID, currentSort, currentOrder, selectedTags, tagMode, allTags)
                @TypesDropdown(path, targetID, currentSort, currentOrder, selectedTypes, allTypes)
                {{ toggled := "desc" }}
                if currentOrder == "desc" {
                    {{ toggled = "asc" }}
                }
                <a
                    class="uk-btn uk-btn-default uk-btn-small uk-btn-icon ctrl-btn"
                    href={ templ.URL(fmt.Sprintf("%s?sort=%s&order=%s", path, currentSort, toggled)) }
                    hx-get={ fmt.Sprintf("%s?sort=%s&order=%s", path, currentSort, toggled) }
                    hx-include="#tag-filter-form input[name=sort], #tag-filter-form input[name=order], #tag-filter-form input[name=tag_mode], #tag-filter-form input[name=tags], #type-filter-form input[name=types], #search-filter-input"
                    hx-replace-url="true"
                    hx-target={ "#" + targetID }
                    hx-push-url="true"
                    aria-label="Toggle sort order"
                >
                    if currentOrder == "asc" {
                        <uk-icon icon="ArrowUpDown"></uk-icon>
                    } else {
                        <uk-icon icon="ArrowDownUp"></uk-icon>
                    }
                </a>
            </div>
        } else {
            // Account pages variant using form-based include
            <div class="flex items-center gap-2">
                <div class="uk-inline">
                    <form id={ targetID + "-sort-form" }>
                        <input type="hidden" name="order" value={ currentOrder }>
                        <uk-select placeholder="Sort by" cls-custom="button: uk-btn uk-btn-default uk-btn-small" hx-get={ path } hx-target={ "#" + targetID } hx-include={ "#" + targetID + "-sort-form, #" + targetID + "-search-input" } hx-push-url="true" hx-replace-url="true" hx-trigger="uk-select:input">
                            <select hidden name="sort" id={ targetID + "-sort-select" }>
                                for _, s := range sorts {
                                    if s.Key == currentSort || (currentSort == "title" && s.Key == "name") {
                                        <option value={ s.Key } selected>{ s.Label }</option>
                                    } else {
                                        <option value={ s.Key }>{ s.Label }</option>
                                    }
                                }
                            </select>
                        </uk-select>
                    </form>
                </div>
                <div class="uk-inline" style="position: relative;">
                    <input
                        id={ targetID + "-search-input" }
                        class="uk-input uk-form-small"
                        type="text"
                        name="search"
                        placeholder="Search by title..."
                        value={ searchFilter }
                        style="padding-right: 32px;"
                        hx-get={ path }
                        hx-target={ "#" + targetID }
                        hx-include={ "#" + targetID + "-sort-form" }
                        hx-push-url="true"
                        hx-replace-url="true"
                        hx-trigger="input changed delay:300ms, search"
                    />
                    if searchFilter != "" {
                        <button
                            type="button"
                            class="uk-btn uk-btn-icon uk-btn-small"
                            style="position: absolute; right: 2px; top: 50%; transform: translateY(-50%); padding: 0; width: 24px; height: 24px; min-height: 24px; background: transparent; border: none;"
                            hx-get={ path }
                            hx-target={ "#" + targetID }
                            hx-include={ "#" + targetID + "-sort-form" }
                            hx-vals='{"search":""}'
                            hx-push-url="true"
                            hx-replace-url="true"
                            aria-label="Clear search"
                        >
                            <uk-icon icon="X" ratio="0.8"></uk-icon>
                        </button>
                    }
                </div>
            </div>
            <div class="flex items-center gap-2">
                {{ toggled := "desc" }}
                if currentOrder == "desc" {
                    {{ toggled = "asc" }}
                }
                <a
                    class="uk-btn uk-btn-default uk-btn-small uk-btn-icon ctrl-btn"
                    href={ templ.URL(fmt.Sprintf("%s?sort=%s&order=%s", path, currentSort, toggled)) }
                    hx-get={ fmt.Sprintf("%s?sort=%s&order=%s", path, currentSort, toggled) }
                    hx-include={ "#" + targetID + "-sort-form, #" + targetID + "-search-input" }
                    hx-replace-url="true"
                    hx-target={ "#" + targetID }
                    hx-push-url="true"
                    aria-label="Toggle sort order"
                >
                    if currentOrder == "asc" {
                        <uk-icon icon="ArrowUpDown"></uk-icon>
                    } else {
                        <uk-icon icon="ArrowDownUp"></uk-icon>
                    }
                </a>
            </div>
        }
    </div>
}

// UnifiedPagination consolidates Pagination + AccountPagination.
templ UnifiedPagination(path string, targetID string, includeTags bool, totalPages int, currentPage int, sort string, order string) {
    <nav class="mt-4" aria-label="Pagination">
        <ul class="uk-pgn uk-pgn-default">
            @UnifiedPaginationItem(path, targetID, includeTags, currentPage > 1, currentPage-1, "Previous", "previous", sort, order)
            @UnifiedPaginationNumbers(path, targetID, includeTags, totalPages, currentPage, sort, order)
            @UnifiedPaginationItem(path, targetID, includeTags, currentPage < totalPages, currentPage+1, "Next", "next", sort, order)
        </ul>
    </nav>
}

templ UnifiedPaginationItem(path string, targetID string, includeTags bool, enabled bool, page int, text string, icon string, sort string, order string) {
    {{ href := fmt.Sprintf("%s?page=%d&sort=%s&order=%s", path, page, sort, order) }}
    {{ includeSelector := "#" + targetID + "-sort-form" }}
    if includeTags {
        {{ includeSelector = "#tag-filter-form input[name=sort], #tag-filter-form input[name=order], #tag-filter-form input[name=tag_mode], #tag-filter-form input[name=tags], #type-filter-form input[name=types]" }}
    }
    if enabled {
        <li>
            <a href={ templ.URL(href) } hx-get={ href } hx-include={ includeSelector } hx-replace-url="true" hx-target={ "#" + targetID } hx-push-url="true">
                if icon != "" {
                    if icon == "next" {
                        <uk-icon icon="ChevronRight"></uk-icon>
                    } else {
                        <uk-icon icon="ChevronLeft"></uk-icon>
                    }
                } else {
                    { text }
                }
            </a>
        </li>
    } else {
        <li class="uk-disabled">
            <a href={ templ.URL(href) } hx-get={ href } hx-include={ includeSelector } hx-replace-url="true" hx-target={ "#" + targetID } hx-push-url="true">
                if icon != "" {
                    if icon == "next" {
                        <uk-icon icon="ChevronRight"></uk-icon>
                    } else {
                        <uk-icon icon="ChevronLeft"></uk-icon>
                    }
                } else {
                    { text }
                }
            </a>
        </li>
    }
}

templ UnifiedPaginationNumbers(path string, targetID string, includeTags bool, totalPages int, currentPage int, sort string, order string) {
    for i := 1; i <= totalPages; i++ {
        if i == currentPage {
            <li class="uk-active"><span>{ fmt.Sprint(i) }</span></li>
        } else if i == 1 || i == totalPages || (i >= currentPage-2 && i <= currentPage+2) {
            @UnifiedPaginationItem(path, targetID, includeTags, true, i, fmt.Sprint(i), "", sort, order)
        } else if (i == 2 && currentPage > 4) || (i == totalPages-1 && currentPage < totalPages-3) {
            <li class="uk-disabled"><span>…</span></li>
        }
    }
}